<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Serialization Protocols</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<!-- horrible intendation for a reason, because I don't want to read everything nested to far. -->

<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        # Serialization Protocols in Scala
        a shootout

        ---

        ## Reasoning
        so why is this even important?


        --

        ### System designs are changing

        1. Microservice architectures are becoming mainstream
        1. Queues (and distributed commit logs used as queues) show up in mainstream architectures
        1. CQRS / ES is a common design nowadays, especially with the rising popularity of DDD
        1. We're not using databases as integration layer anymore. (I hope?!...)

        --

        > Distributed systems are about protocols, not implementations. Forget languages, protocols are everything.

        [@TimPerret](https://twitter.com/timperrett/status/748590102926884864)


        --

        ## Evolvability

        > The ability of a system and its data to adopt to change

        --

        ## Evolvability

        In the world of monolythic systems and relational databases, a change in the data model was usually implemented by a schema migration (and code changes)

        --

		## Evolvability Examples

        * monolithic systems and relational databases
        * replicated systems 
        * systems with code distributed to the user

        --

        ## Persistence

        * on-disk formats behave significantly different than in-memory formats

        * Data needs to be encoded/serialized/marshalled

        * to get it back you need to decode/deserialize/unmarshall

    </script>
</section>
<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Usual suspects

        --

        ### Programming Language provided serialization

        we get `java.io.Serializable` for free, so why not just use it?

        --

        ### NoooooooooOOoo

        * We are bound to one implementation language 
        * The performance is awful
        * It has some serious drawbacks

        --

        > Implement `Serializable` judiciously
        [Joshua Bloch, Effective Java]

        * decreases the flexibilty to change the class once it is released
        * The inner implementation of your class becomes the API
        * increases the likelyhood of bugs and security holes (Stack Overflows)
        * increases the testing burden

        --

        ### Some notes about Performance

        |protocol| create |ser|deser|total|size|
        |--|--|--|--|--|--|
        |protobuf|121|1173|719|1891|239|
        |thrift|95|1455|731|2186|349|
        |kryo-flat|55|705|909|1614|268|
        |avro-generic|329|1721|984|2704|221|
        |scala/java-built-in|514|8280|36105|44385|1293|

        [Source](https://github.com/eishay/jvm-serializers/wiki)

        --

        ### Some notes about performance

        * as long as its one of our four, it's probably fast enough
        * if you need it faster, you'll have to do your own research
        * just don't use the built in serializer

        --

        ### But... how about JSON? Or XML?

        * widespread
        * somewhat human readable
        * still slow (depending on the benchmark)
        * verbose
        * number handling is difficult
        * character encoding is difficult

        --

        ### But... how about JSON? Or XML?

        There also exists a various range of schema extensions for JSON.
        Unfortunately they don't provide schema evolabiltiy, so i'll skip them


    </script>
</section>
<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Schema evolvability

        --

        ### Reading Data between Schemas

        <img src="/media/broken_deployments.svg"  height="300" width="700">


        --

        ### Backwards compatibility

        This means a newer Schema can read Data encoded with an older Schema.

        That's halfway (not) easy. You know how the previous schema was, you can deal with missing things in your code. If you are aware of that.

        --

        ### Forwards compatibiltiy

        Reading Data from a Schema that is newer that the Schema of the running Software.

        Ouch. How do you deal with things you don't know about?

        --

        ### Forwards compatibiltiy

        Let a Protocol handle this for us!

        
    </script>
</section>
<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Protobuf

        --

        What is Protbuf (protocol buffers)?

        > Protocol buffers are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data â€“ think XML, but smaller, faster, and simpler. 

        Besides the specification, Google provides a compiler for Java

        --

        ## ScalaPB

        ScalaPB is a protocol buffer compiler `(protoc)` plugin for Scala. It will generate Scala case classes, parsers and serializers for your protocol buffers

        --

        ## Schema Sample

        ```
        syntax = "proto3";

        package de.christianuhl.proto;

        message Person {
            int32 user_id = 1;
            string firstname = 2;
            string lastname = 3;
        }
        ```

        --

        ### Usage with SBT

        (live Sample)

        --

        ### Let's check the encoding on Disk

        |field tag| type |value |length |bytes / value |
        |--|--|--|--|--|--|
        |00010|010|12|09|43687269 73746961 6E|
        |00011|010|1A|03|0355686C|

        --

        ### Proto 2 vs Proto 3

        Significant changes:

        * No presence logic anymore
        * All values are optional by default, `required` semantic is removed
        * `Map` Type
        * Timevalues

        --

        ### Why the radical 'everything is optional'?   

        * `required` breaks schema evolvabiltiy anywas
        * loads of production issues
        * was already banned in google anyways
        * `optional` became rendundant and was removed as well

    </script>
</section>

<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Avro
    	
    </script>
</section>

<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Thrift
    	
    </script>
</section>

<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Kryo
    	
    </script>
</section>

<section data-markdown data-separator="^\n---\n$" data-separator-vertical="^\n--\n$">
    <script type="text/template">
        ## Summary
    	
    </script>
</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
